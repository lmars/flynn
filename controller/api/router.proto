syntax = 'proto3';

package flynn.api.v1;

option go_package = 'api';

import "google/protobuf/timestamp.proto";

// Flynn Router gRPC API v1
service Router {
  // SetRoutes takes a desired list of routes for a set of apps, calculates the
  // changes that are needed to the existing routes to realise that list, and
  // then either atomically applies those changes or returns them for user
  // confirmation (otherwise known as a dry run).
  //
  // The given list of routes for each app is expected to contain the desired
  // configuration for all of the app's routes, and so if any existing routes
  // are not contained in the list, or they match ones in the list but have
  // different configuration, then they will be either deleted or updated.
  rpc SetRoutes(SetRoutesRequest) returns (SetRoutesResponse);

  // ListAppRoutes list routes for a set of apps.
  rpc ListAppRoutes(ListAppRoutesRequest) returns (ListAppRoutesResponse);

  // Lists TLS keys that can be referenced by static certificates.
  rpc ListKeys(ListKeysRequest) returns (ListKeysResponse) {}

  // Gets a TLS private key.
  rpc GetKey(GetKeyRequest) returns (GetKeyResponse) {}

  // Creates a TLS key. If the key already exists, it will be returned instead
  // of creating a duplicate, making the method idempotent.
  rpc CreateKey(CreateKeyRequest) returns (CreateKeyResponse) {}

  // Deletes a TLS key. The key must not be referenced by any routes. This
  // method is idempotent and will not return an error if the specified key has
  // already been deleted.
  rpc DeleteKey(DeleteKeyRequest) returns (DeleteKeyResponse) {}

  // Internal only. Updates a managed certificate.
  rpc UpdateManagedCertificate(UpdateManagedCertificateRequest) returns (UpdateManagedCertificateResponse) {}

  // Create an ACME account
  rpc CreateACMEAccount(CreateACMEAccountRequest) returns (CreateACMEAccountResponse) {}

  // Internal only. Get an ACME Account key
  rpc GetACMEAccountKey(GetACMEAccountKeyRequest) returns (GetACMEAccountKeyResponse) {}
}

// SetRoutesRequest is a request to set a list of app routes.
message SetRoutesRequest {
  // app_routes are the app routes to set.
  repeated AppRoutes app_routes = 1;

  // dry_run indicates whether to just generate the changes that would be
  // applied to existing routes by this request (true) or to also atomically
  // apply the route changes (false).
  bool dry_run = 2;

  // expected_state is the expected state of existing routes to apply this
  // request to, with the request failing if the actual state differs.
  bytes expected_state = 3;
}

// SetRoutesResponse is a response to a SetRoutes request.
message SetRoutesResponse {
  // route_changes is the list of route changes that were either applied if
  // dry_run=false or that would have been applied if dry_run=true.
  repeated RouteChange route_changes = 1;

  // dry_run indicates whether the request was a dry run or not.
  bool dry_run = 2;

  // applied_to_state is the state of the existing routes that this request was
  // applied to, and can be used as the expected_state in a subsequent request
  // to confirm the application of a dry run.
  bytes applied_to_state = 3;
}

// ListAppRoutesRequest is a request to list routes for a set of apps.
message ListAppRoutesRequest {
  // apps is the set of apps to list routes for.
  repeated string apps = 1;
}

// ListAppRoutesResponse is a response to list routes for a set of apps.
message ListAppRoutesResponse {
  // app_routes are the requested routes.
  repeated AppRoutes app_routes = 1;

  // state is the state of the returned routes that can be used as the
  // expected_state in a subsequent call to SetRoutes.
  bytes state = 2;
}

// A request to list TLS keys.
message ListKeysRequest {
}

// A response containing a list of TLS keys.
message ListKeysResponse {
  // The TLS keys.
  repeated Key keys = 1;
}

// A request to get a TLS private key.
message GetKeyRequest {
  // Required. The name of the TLS key to get in the format `tls-keys/{KEY_ID}`
  string name = 1;
}

// A response containing a TLS private key.
message GetKeyResponse {
  // The DER-encoded TLS private key.
  bytes private_key = 1;
}

// A request to create a new TLS key.
message CreateKeyRequest {
  // Required. The private key data. It must be DER-encoded PKCS#1 (RSA),
  // PKCS#8 (RSA/ECC), or SEC1 (ECC).
  bytes private_key = 1;
}

// A response containing a TLS key that was created.
message CreateKeyResponse {
  // The TLS key that was created.
  Key key = 1;
}

// A request to delete a TLS key.
message DeleteKeyRequest {
  // Required. The TLS key resource name in the format `tls-keys/{KEY_ID}`
  string name = 1;
}

// A response containing a TLS key that was deleted.
message DeleteKeyResponse {
  // The TLS key that was deleted.
  Key key = 1;
}

// A request to update a managed certificate.
message UpdateManagedCertificateRequest {
  // The managed certificate to update.
  ManagedCertificate certificate = 1;
}

// A response containing a managed certificate that was updated.
message UpdateManagedCertificateResponse {
  // The managed certificate that was updated.
  ManagedCertificate certificate = 1;
}

message CreateACMEAccountRequest {
  ACMEAccount account = 1;

  bytes private_key = 2;
}

message CreateACMEAccountResponse {
  ACMEAccount account = 1;
}

message GetACMEAccountKeyRequest {
  string name = 1;
}

message GetACMEAccountKeyResponse {
  bytes private_key = 1;
}

// AppRoutes is a list of desired routes for an app.
message AppRoutes {
  // app is an identifier for the app.
  string app = 1;

  // routes are the desired routes for the app.
  repeated Route routes = 2;
}

// RouteChange is a change made to a route in response to a SetRoutes request.
message RouteChange {
  enum Action {
    // Unused/invalid default value.
    ACTION_UNSPECIFIED = 0;

    // ACTION_CREATE represents a route that was created.
    ACTION_CREATE = 1;

    // ACTION_UPDATE represents a route that was updated.
    ACTION_UPDATE = 2;

    // ACTION_DELETE represents a route that was deleted.
    ACTION_DELETE = 3;
  }

  // action is the action that was performed.
  Action action = 1;

  // before is the route before the action was applied.
  Route before = 2;

  // after is the route after the action was applied.
  Route after = 3;
}

// Route is a HTTP or TCP route.
message Route {
  // A discoverd service target.
  message ServiceTarget {
    // Required. The discoverd service name to route requests to.
    string service_name = 1;

    // Route to the service leader.
    bool leader = 2;

    // Wait for in-flight requests to this target to finish before backends are terminated.
    bool drain_backends = 3;
  }

  // The TLS configuration for a route.
  message TLS {
    // Required. The certificate to use for TLS handshakes with this route.
    Certificate certificate = 1;
  }

  message HTTP {
    // Sticky session configuration. Currently there are no configuration options.
    message StickySessions {}

    // Required. The name of the server that this route matches. May contain up
    // to 10 wildcard labels for plaintext HTTP routes or a single wildcard
    // label for TLS routes, followed by one or more non-wildcard labels. This
    // is matched against SNI to choose the TLS configuration and the Host
    // header to select the route.
    string domain = 1;

    // The HTTP path prefix to match against. Defaults to the root path `/`. To
    // create a route with a non-root path prefix, a root path route must already
    // exist for the same listener and domain, which will be used for the TLS and
    // HSTS configuration. Trailing slashes are stripped and only full path
    // segments are matched. The full unstripped path is sent in requests to the
    // target.
    string path = 2;

    // The TLS configuration for the route.
    TLS tls = 3;

    // Enables best-effort session-backend stickiness using an encrypted cookie set
    // and managed by the router that will send requests containing the cookie to
    // the same backend instance. Incompatible with RedirectTarget.
    StickySessions sticky_sessions = 4;
  }

  message TCP {
    // The TCP port configuration for the route. Required and only valid for TCP
    // listeners.
    TCPPort port = 1;
  }

  message TCPPort {
    // The TCP port to bind to. If unspecified, a port will be automatically chosen
    // during route creation and provided in the response.
    uint32 port = 1;
  }

  // Output only. The unique identifier of this route resource in the format:
  // `apps/{APP_ID}/routes/{ROUTE_ID}`
  string name = 1;

  // Required. The parent resource name, in the format `apps/{APP_ID}` or
  // `apps/{APP_DISPLAY_NAME}`
  string parent = 2;

  // Required. The discoverd service target for this route.
  ServiceTarget service_target = 3;

  // Disable keep-alives between the router and backends for this route.
  bool disable_keep_alives = 4;

  // The protocol-specific configuration.
  oneof config {
    // An HTTP route configuration.
    HTTP http = 5;

    // A TCP route configuration.
    TCP tcp = 6;
  }
}

// A TLS key.
message Key {
  // A TLS key algorithm.
  enum Algorithm {
    // Default value.
    KEY_ALG_UNSPECIFIED = 0;

    // NIST ECC P-256 curve
    KEY_ALG_ECC_P256 = 1;

    // 2048-bit RSA
    KEY_ALG_RSA_2048 = 2;

    // 4096-bit RSA
    KEY_ALG_RSA_4096 = 3;
  }

  // The unique identifier of this TLS key.
  string name = 1;

  // The algorithm used by this TLS key.
  Algorithm algorithm = 2;

  // The certificates that reference this TLS key.
  repeated string certificates = 3;

  // The timestamp when this TLS key was created.
  google.protobuf.Timestamp create_time = 4;
}

message Certificate {
  oneof certificate {
    ManagedCertificate managed = 1;

    StaticCertificate static = 2;
  }
}

// An existing TLS certificate.
message StaticCertificate {
  // The status of the certificate.
  enum Status {
    // Unused/invalid default value.
    STATUS_UNSPECIFIED = 0;

    // The certificate is valid.
    STATUS_VALID = 1;

    // The certificate has expired.
    STATUS_EXPIRED = 2;

    // The certificate has been revoked.
    STATUS_REVOKED = 3;

    // The certificate is not valid yet.
    STATUS_FUTURE_NOT_BEFORE = 4;

    // The chain is invalid due to issues like issuer/subject mismatch,
    // unsatisfied constraints, and intermediate expiry.
    STATUS_INVALID = 5;
  }

  // Required. A list of DER-encoded X.509 certificates, composing a chain of
  // exactly one leaf (non-CA/intermediate) certificate followed by zero or
  // more intermediate CA certificates that may be used to form a valid trust
  // chain from client platform trusted roots to the leaf.
  repeated bytes chain = 1;

  // By default a variety of checks are performed before creating
  // a certificate. When no_strict is set to true, the certificate chain will
  // be accepted as-is with no modification, and without performing additional
  // checks. When set, the only preconditions are that the leaf certificate
  // must be the first certificate in the chain.
  bool no_strict = 2;

  // The unique DNS names included in the leaf certificate Subject
  // Alternative Names.
  repeated string domains = 3;

  // The status of the certificate chain. This reflects revocation and
  // validation errors in the chain, it does not indicate compatiblity with any
  // client or platform.
  Status status = 4;

  // A human-readable status description, only set when the status is not VALID.
  string status_detail = 5;

  // The issuer organization of the leaf certificate.
  string issuer = 6;

  // The key algorithm used in the leaf certificate.
  Key.Algorithm key_algorithm = 7;

  // The notBefore timestamp from the leaf certificate, indicating the start of
  // the validity period.
  google.protobuf.Timestamp not_before = 8;

  // The notBefore timestamp from the leaf certificate, when the leaf
  // certificate expires.
  google.protobuf.Timestamp not_after = 9;

  // When true, a TLS Feature extension is included which specifies that an OCSP
  // staple must be included in all TLS handshakes with this certificate.
  bool ocsp_must_staple = 10;

  // The SHA-256 hash of the DER-encoded leaf certificate. Multiple certificate
  // resources may have the same fingerprint if they have a different chain.
  bytes leaf_fingerprint = 11;

  // The SHA-256 hash of the DER-encoded leaf certificate Subject Public Key
  // Information. Multiple certificate resources will have the same fingerprint
  // if they share the same keypair.
  bytes spki_fingerprint = 12;

  // An opaque 32-byte fingerprint that uniquely identifies the certificate
  // chain. This is used internally for duplicate detection, and will be the
  // same if a certificate is deleted and recreated with the exact same chain.
  bytes chain_fingerprint = 13;

  // The timestamp when this certificate was created.
  google.protobuf.Timestamp create_time = 14;
}

// An automatically provisioned TLS certificate.
message ManagedCertificate {
  // A domain validation method.
  enum ValidationMethod {
    // The default value.
    METHOD_UNSPECIFIED = 0;

    // Automatically managed domain validation, the domain must have CNAME
    // or A/AAAA records pointing at the Flynn cluster's ports 80 and 443 for
    // validation to succeed.
    METHOD_AUTO = 1;
  }

  // A single DNS name that will be a Subject Alternative Name in the
  // certificate.
  message Domain {
    // Required. The domain name to include in the certificate.
    string domain = 1;

    // The validation method to use to confirm domain control.
    ValidationMethod validation_method = 2;
  }

  // Configuration for the certificate.
  message Config {
    // Required. One or more DNS names to include in the certificate as Subject
    // Alternative Names.
    repeated Domain domains = 1;

    // The key algorithm to use for the certificate. If unspecified, defaults to
    // KEY_ALG_ECC_P256.
    Key.Algorithm key_algorithm = 2;
  }

  // The issuance status of the managed certificate.
  enum Status {
    // Unused/invalid default value.
    STATUS_UNSPECIFIED = 0;

    // The initial state of a managed certificate, pending validation or
    // issuance, can transition to ISSUED or FAILED.
    STATUS_PENDING = 1;

    // The certificate has been successfully validated and issued.
    STATUS_ISSUED = 2;

    // Certificate issuance failed. Check errors for details.
    STATUS_FAILED = 3;
  }

  // An error encountered during certificate issuance.
  message Error {
    // The error type, usually one specified by ACME.
    string type = 1;

    // Human-readable error details.
    string detail = 2;
  }

  // The immutable list of domains included in this certificate as Subject
  // Alternative Names.
  repeated string domains = 1;

  // Configuration for the certificate.
  Config config = 2;

  // The certificate issuance status. The initial value is PENDING.
  Status status = 3;

  // Errors encountered during issuance, if any. This will only be populated if
  // the status is FAILED.
  repeated Error errors = 4;

  // The current certificate details. This will not be set until the certificate
  // is issued.
  StaticCertificate certificate = 5;

  // The timestamp of the last modification of this resource. It is modified
  // each time at least one field is changed.
  google.protobuf.Timestamp update_time = 6;
}

message ACMEAccount {
  string name = 1;

  string directory_url = 2;

  repeated string contacts = 3;

  bool terms_of_service_agreed = 4;
}
